/* main.c generated by valac 0.14.0, the Vala compiler
 * generated from main.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glut.h>
#include <stdlib.h>
#include <string.h>
#include <GL/glfw.h>




#define TIMER_CALLS_PS 60
void setProjection (GLdouble aspect);
void cbTimer (gint lastCallTime);
static void _cbTimer_gluton_gluttimerfunc (gint _val1);
void cbDisplay (void);
void cbReshape (gint w, gint h);
void registerCallbacks (void);
static void _cbReshape_gluton_glutreshapefunc (gint _val1, gint _val2);
static void _cbDisplay_gluton_glutdisplayfunc (void);
gboolean initAndStartIO (gint width, gint height);
gint _vala_main (void);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


/**
 * Setzen der Projektionsmatrix.
 * Setzt die Projektionsmatrix fuer die Szene.
 *
 * @param aspect Seitenverhaeltnis des Anzeigefensters (In).
 */
void setProjection (GLdouble aspect) {
	GLdouble _tmp0_;
	glMatrixMode ((GLenum) GL_PROJECTION);
	glLoadIdentity ();
	_tmp0_ = aspect;
	if (_tmp0_ <= ((GLdouble) 1)) {
		GLdouble _tmp1_;
		GLdouble _tmp2_;
		_tmp1_ = aspect;
		_tmp2_ = aspect;
		gluOrtho2D ((GLdouble) (-1.0), (GLdouble) 1.0, (GLdouble) ((-1.0) / _tmp1_), (GLdouble) (1.0 / _tmp2_));
	} else {
		GLdouble _tmp3_;
		GLdouble _tmp4_;
		_tmp3_ = aspect;
		_tmp4_ = aspect;
		gluOrtho2D ((GLdouble) ((-1.0) * _tmp3_), (GLdouble) (1.0 * _tmp4_), (GLdouble) (-1.0), (GLdouble) 1.0);
	}
}


/**
 * Timer-Callback.
 * Initiiert Berechnung der aktuellen Position und Farben und anschliessendes
 * Neuzeichnen, setzt sich selbst erneut als Timer-Callback.
 *
 * @param lastCallTime Zeitpunkt, zu dem die Funktion als Timer-Funktion
 *   registriert wurde (In).
 */
static void _cbTimer_gluton_gluttimerfunc (gint _val1) {
	cbTimer (_val1);
}


void cbTimer (gint lastCallTime) {
	gint _tmp0_ = 0;
	gint thisCallTime;
	_tmp0_ = glutGet (GLUT_ELAPSED_TIME);
	thisCallTime = _tmp0_;
	glutTimerFunc ((guint) (1000 / TIMER_CALLS_PS), _cbTimer_gluton_gluttimerfunc, thisCallTime);
	glutPostRedisplay ();
}


/**
 * Zeichen-Callback.
 * Loescht die Buffer, ruft das Zeichnen der Szene auf und tauscht den Front-
 * und Backbuffer.
 */
void cbDisplay (void) {
	glClear ((GLbitfield) GL_COLOR_BUFFER_BIT);
	glMatrixMode ((GLenum) GL_MODELVIEW);
	glBegin ((GLenum) GL_QUADS);
	glVertex3f ((GLfloat) (-1.0f), (GLfloat) 1.0f, (GLfloat) 0.0f);
	glVertex3f ((GLfloat) 1.0f, (GLfloat) 1.0f, (GLfloat) 0.0f);
	glVertex3f ((GLfloat) 1.0f, (GLfloat) (-1.0f), (GLfloat) 0.0f);
	glVertex3f ((GLfloat) (-1.0f), (GLfloat) (-1.0f), (GLfloat) 0.0f);
	glEnd ();
	glutSwapBuffers ();
}


/**
 * Callback fuer Aenderungen der Fenstergroesse.
 * Initiiert Anpassung der Projektionsmatrix an verÃ¤nderte Fenstergroesse.
 * @param w Fensterbreite (In).
 * @param h Fensterhoehe (In).
 */
void cbReshape (gint w, gint h) {
	gint _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	_tmp0_ = w;
	_tmp1_ = h;
	glViewport ((GLint) 0, (GLint) 0, (GLsizei) _tmp0_, (GLsizei) _tmp1_);
	_tmp2_ = w;
	_tmp3_ = h;
	setProjection (((GLdouble) _tmp2_) / ((GLdouble) _tmp3_));
	g_print ("test!");
}


/**
 * Registrierung der GLUT-Callback-Routinen.
 */
static void _cbReshape_gluton_glutreshapefunc (gint _val1, gint _val2) {
	cbReshape (_val1, _val2);
}


static void _cbDisplay_gluton_glutdisplayfunc (void) {
	cbDisplay ();
}


void registerCallbacks (void) {
	gint _tmp0_ = 0;
	_tmp0_ = glutGet (GLUT_ELAPSED_TIME);
	glutTimerFunc ((guint) (1000 / TIMER_CALLS_PS), _cbTimer_gluton_gluttimerfunc, _tmp0_);
	glutReshapeFunc (_cbReshape_gluton_glutreshapefunc);
	glutDisplayFunc (_cbDisplay_gluton_glutdisplayfunc);
}


gboolean initAndStartIO (gint width, gint height) {
	gboolean result = FALSE;
	gint argc;
	gchar* _tmp0_;
	gchar** _tmp1_ = NULL;
	gchar** argv;
	gint argv_length1;
	gint _argv_size_;
	gchar** _tmp2_;
	gint _tmp2__length1;
	gint _tmp3_;
	gint _tmp4_;
	gboolean _tmp5_ = FALSE;
	argc = 1;
	_tmp0_ = g_strdup ("cmd");
	_tmp1_ = g_new0 (gchar*, 1 + 1);
	_tmp1_[0] = _tmp0_;
	argv = _tmp1_;
	argv_length1 = 1;
	_argv_size_ = argv_length1;
	glfwInit ();
	_tmp2_ = argv;
	_tmp2__length1 = argv_length1;
	glutInit (&argc, _tmp2_);
	_tmp3_ = width;
	_tmp4_ = height;
	_tmp5_ = glfwOpenWindow (_tmp3_, _tmp4_, 0, 0, 0, 0, 0, 0, GLFW_WINDOW);
	if (!_tmp5_) {
		glfwTerminate ();
		result = FALSE;
		argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
		return result;
	}
	result = TRUE;
	argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


gint _vala_main (void) {
	gint result = 0;
	gboolean _tmp0_ = FALSE;
	gboolean running;
	_tmp0_ = initAndStartIO (640, 480);
	running = _tmp0_;
	setProjection (((GLdouble) 640) / 480);
	while (TRUE) {
		gboolean _tmp1_;
		gboolean _tmp2_ = FALSE;
		gboolean _tmp3_ = FALSE;
		gboolean _tmp5_;
		_tmp1_ = running;
		if (!_tmp1_) {
			break;
		}
		registerCallbacks ();
		_tmp3_ = glfwGetKey (GLFW_KEY_ESC);
		if (!_tmp3_) {
			gint _tmp4_ = 0;
			_tmp4_ = glfwGetWindowParam (GLFW_OPENED);
			_tmp2_ = (gboolean) _tmp4_;
		} else {
			_tmp2_ = FALSE;
		}
		_tmp5_ = _tmp2_;
		running = _tmp5_;
	}
	glfwTerminate ();
	result = 0;
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return _vala_main ();
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



